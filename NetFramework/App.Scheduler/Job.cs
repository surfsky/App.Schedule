using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Reflection;
using Newtonsoft.Json;

namespace App.Scheduler
{
    /// <summary>
    /// 任务运行器接口
    /// </summary>
    public interface IJobRunner
    {
        bool Run(DateTime dt, string data);
    }

    /// <summary>
    /// 任务状态
    /// </summary>
    [JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
    public enum JobStatus
    {
        Waiting,
        Running,
        Success,
        Failure
    }

    /*
    /// <summary>
    /// 任务参数
    /// </summary>
    public struct JobParameter
    {
        public DateTime Dt { get; set; }
        public string Data { get; set; }
    }
    */


    /// <summary>
    /// 任务基类
    /// 参照 Quartz cron 表达式: https://yq.aliyun.com/articles/62723#_Toc465868115
    /// - 顺序调整为：年 月 日 时 分 周
    /// - 每个部分可用逗号分隔
    /// - 只保留 * 符号
    /// </summary>
    public class Job : IJobRunner
    {
        /// <summary>ID</summary>
        public string ID { get; set; }

        /// <summary>名称</summary>
        public string Name { get; set; }

        /// <summary>是否有效</summary>
        public bool Enable { get; set; } = true;

        /// <summary>调度表达式。格式为"年 月 日 时 分 周"。如"* * * 8,18, * *"表示每日8点、18点运行</summary>
        public Schedule Schedule { get; set; }

        /// <summary>任务完成状态</summary>
        public JobStatus Status { get; set; } = JobStatus.Success;

        /// <summary>最后运行时间</summary>
        public DateTime LastRunDt { get; set; }

        /// <summary>上次成功运行后，再次运行需要的时间间隔</summary>
        public DateSpan Success { get; set; }

        /// <summary>上次运行失败后，再次运行需要的时间间隔</summary>
        public DateSpan Failure { get; set; } = new DateSpan(0, 0, 0, 0, 5, 0, 0, 9);

        //-------------------------------------------
        /// <summary>运行器的类型(ITaskRunner)</summary>
        [JsonConverter(typeof(TypeNameConverter))]
        public Type Runner { get; set; }

        /// <summary>运行参数</summary>
        public string Data { get; set; }

        /// <summary>依赖的前置任务（依赖任务全部完成后，本任务才运行）</summary>
        public List<Job> Dependency { get; set; } = new List<Job>();


        //-------------------------------------------
        // 构造函数
        //-------------------------------------------
        public Job()
        {
            this.Runner = this.GetType();
        }
        public Job(string id, string name, string schedule, DateSpan interval, DateSpan failure=null)
        {
            this.ID = id;
            this.Name = name;
            this.Schedule = new Schedule(schedule);
            this.Success = interval;
            this.Failure = failure ?? new DateSpan(0, 0, 0, 0, 0, 0, 0, 0);
            this.Runner = this.GetType();
        }


        //-------------------------------------------
        // 方法
        //-------------------------------------------
        /// <summary>真正的任务运行逻辑，供子类实现。IRunner接口成员</summary>
        public virtual bool Run(DateTime dt, string data)
        {
            return true;
        }

        // 获取ITaskRunner对象
        private IJobRunner _runner;
        [JsonIgnore] 
        public IJobRunner JobRunner
        {
            get
            {
                if (_runner == null)
                {
                    var assembly = Assembly.GetAssembly(this.Runner);
                    _runner = assembly.CreateInstance(this.Runner.FullName) as IJobRunner;
                }
                return _runner;
            }
        }
    }

    /// <summary>
    /// Type 名称 Json 转化器，只保留类名和数据集名，不记录数据集版本号
    /// </summary>
    public class TypeNameConverter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType.FullName == "System.RuntimeType";
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            string name = reader.Value.ToString();
            return Type.GetType(name);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            Type type = (Type)value;
            writer.WriteValue(string.Format("{0}, {1}", type.FullName, type.Assembly.GetName().Name));
        }
    }
}
